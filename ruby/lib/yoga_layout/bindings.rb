require 'ffi'

# Our C extension, which loads the Yoga C code.
require "yoga_layout/yoga_layout"

module YogaLayout
  # Native is the libffi wrapper around Yoga.
  # It does not implement anything novel like memory management or nice ruby types.
  # It's just a compatibility layer.
  module Bindings
    extend ::FFI::Library
    # ref https://github.com/ffi/ffi/wiki/Loading-Libraries#in-memory-libraries
    ffi_lib ::FFI::USE_THIS_PROCESS_AS_LIBRARY

    def self.functions
      @functions ||= {}
    end

    # Wrapper around FFI::Library.attach_function that also remembers the function
    # name and arguments for later static analysis
    def self.remember_function(*args)
      result = attach_function(*args)
      functions[args.first] = args
      result
    end

    # Retrieve a pointer to a Ruby object
    #
    # @param obj [Object]
    # @return [::FFI::Pointer]
    def self.ruby_to_pointer(obj)
      addr = obj.object_id << 1
      ::FFI::Pointer.new(:pointer, addr)
    end

    # Retrieve the Ruby object represented by an ffi_pointer (or any object
    # with #to_i).
    #
    # This is dangerous, as there's no guarantee that the ffi_pointer actually
    # points to a ruby object, and even if it *did* point to a ruby object,
    # that object could have been garbage collected.
    #
    # Make sure your Ruby object outlives any pointers to it!
    #
    # @param ffi_pointer [::FFI::Pointer, #to_i] a pointer or address
    # @return [Object] The ruby object at that address
    def self.pointer_to_ruby(ffi_pointer)
      require 'fiddle'
      fiddle = ::Fiddle::Pointer.new(ffi_pointer.to_i)
      fiddle.to_value
    end

    # Auto-genrated by ../../enums.py
    require 'yoga_layout/bindings/enums'

    # Written by hand
    require 'yoga_layout/bindings/typedefs'
    require 'yoga_layout/bindings/ygnode'
    require 'yoga_layout/bindings/ygconfig'
    require 'yoga_layout/bindings/misc'

    # Auto-generated by `rake ygnode_properties`
    require 'yoga_layout/bindings/ygnode_properties'
  end
end
